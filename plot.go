package plot

import (
	"code.google.com/p/plotinum/vg"
	"code.google.com/p/plotinum/vg/vgimg"
	"fmt"
	"image/color"
	"io"
	"math"
	"os"
	"sort"
	"strings"
	"time"
)

var now = time.Now
var col = color.RGBA{}
var floor = math.Floor
var _ = os.Open

// Plot represents a whole plot.
type Plot struct {
	// The title of the plot.
	Title string

	// Data is the data to draw.
	Data *DataFrame

	// Faceting describes the Used Faceting
	Faceting Faceting

	// Mapping describes how fieleds in data are mapped to Aesthetics.
	Aes AesMapping

	// Layers contains all the layers displayed in the plot.
	Layers []*Layer

	// Scales can be used to set up non-default scales, e.g.
	// scales with a transformation or manualy set breaks.
	//
	// The scales of plot are distributed to the individual panels
	// only and are not used directly as scales.
	Scales map[string]*Scale

	// Panels are the different panels for faceting
	Panels [][]*Panel

	// Theme contains the visual defaults to use when drawing things.
	Theme Theme

	// Layout maps components like "Title" or "Y-Label" to their viewport.
	Viewport map[string]Viewport
}

func NewPlot(data interface{}, aesthetics AesMapping) (*Plot, error) {
	df, err := NewDataFrameFrom(data)
	if err != nil {
		return nil, err
	}

	if aesthetics == nil {
		aesthetics = make(AesMapping)
	}

	plot := Plot{
		Data:     df,
		Faceting: Faceting{},
		Aes:      aesthetics,
		Layers:   nil,
		Scales:   make(map[string]*Scale),
		Panels:   nil,
		Theme:    DefaultTheme,
	}

	return &plot, nil
}

// Layer represents one layer of data in a plot.
type Layer struct {
	Panel *Panel
	Name  string

	// A nil Data will use the Data from the plot this Layer belongs to.
	Data *DataFrame

	// DataMapping is combined with the plot's AesMapping and used to
	// map fields in Data to aesthetics.
	DataMapping AesMapping

	// Stat is the statistical transformation used in this layer.
	Stat Stat

	// New (i.e. generated by the stat) fields may be mapped to
	// aesthetics with StatMapping
	StatMapping AesMapping

	// Geom is the geom to use for this layer.
	Geom Geom

	// The fundamental geoms to draw.
	Fundamentals []Fundamental

	// GeomMapping is used to wire fields output by the statistical
	// transform to the input fields used by the geom.
	GeomMapping AesMapping

	Grobs []Grob
}

// A Panel is one panel, typically in a facetted plot.
// It does not differ much from a Plot as it actually represents
// one of the plots in a facetted plot.
type Panel struct {
	Name string

	Plot *Plot

	// Data is the data to draw.
	Data *DataFrame

	// Mapping describes how fieleds in data are mapped to Aesthetics.
	Aes AesMapping

	// Layers contains all the layers displayed in the plot.
	Layers []*Layer

	// Scales contains the scales for this panel. Normaly all panels
	// share all scales, but x and y might be free on faceted plots.
	Scales map[string]*Scale

	// Viewport
	Viewport Viewport
}

// Facetting describes the facetting to use. The zero value indicates
// no facetting.
type Faceting struct {
	// Columns and Rows are the faceting specification. Each may be a comma
	// seperated list of fields in the Data. An empty string means no
	// faceting in this dimension.
	Columns, Rows string

	// Totals controlls display of totals.
	Totals bool // TODO: fancier control needed

	FreeScale string // "": fixed, "x": x is free, "y": y is free, "xy": both are free

	FreeSpace string // as FreeScale but for width and height of panels
}

type Fundamental struct {
	Geom Geom
	Data *DataFrame
}

func (p *Plot) Warnf(f string, args ...interface{}) {
	if !strings.HasSuffix(f, "\n") {
		f = f + "\n"
	}
	fmt.Printf("Warning "+f, args...)
}

func contains(s []string, t string) bool {
	for _, ss := range s {
		if t == ss {
			return true
		}
	}
	return false
}

func same(s []string, t []string) bool {
	if len(s) != len(t) {
		return false
	}
	for _, x := range s {
		if !contains(t, x) {
			return false
		}
	}
	return true
}

// -------------------------------------------------------------------------
// Step 2: Preparing Data and Scales

// PrepareData is the first step in generating a plot.
// After preparing the data frame the following holds
//   - Layer has a own data frame (maybe a copy of plots data frame)
//   - This data frame has no unused (aka not mapped to aesthetics)
//     columns
//   - The columns name are the aestectics (e.g. x, y, size, color...)
//   - The columns have been transformed according to the
//     ScaleTransform associated with x, y, size, ....
//
// TODO: how about grouping? 69b0d2b contains grouping code.
//
// Step 2 in design.
func (p *Panel) PrepareData() {
	fmt.Printf("Panel %q: PrepareData()\n", p.Name)
	println("UUUUUUUUU")
	p.Data.Print(os.Stdout)

	for i, layer := range p.Layers {
		fmt.Printf("Layer %d %q: PrepareData()\n", i, layer.Name)
		fmt.Printf("p = %p  layer.Panel=%p\n", p, layer.Panel)
		// Step 2a

		// Set up data and aestetics mapping.
		if layer.Data == nil {
			println("Layer data is nil, will copy panel data", layer.Panel.Data.N)
			layer.Panel.Data.Print(os.Stdout)
			layer.Data = layer.Panel.Data.Copy()
			println("Layer data now:")
			layer.Data.Print(os.Stdout)
		}
		aes := MergeAes(layer.DataMapping, layer.Panel.Plot.Aes)

		// Drop all unused (unmapped) fields in the data frame.
		_, fields := aes.Used(false)
		for _, f := range layer.Data.FieldNames() {
			if contains(fields, f) {
				continue
			}
			delete(layer.Data.Columns, f)
		}

		// Rename mapped fields to their aestethic name
		for a, f := range aes {
			layer.Data.Rename(f, a)
		}
		fmt.Printf("PrepareData panel=%q layer=%q\n", p.Name, layer.Name)
		layer.Data.Print(os.Stdout)

		// Step 2b
		layer.Panel.Plot.PrepareScales(layer.Data, aes)
	}
}

// PrepareScales makes sure plot contains all scales needed for the
// aesthetics in aes, the data is scale transformed if requested by the
// scale and the scales are pre-trained.
//
// Only continuous, non-time-scales can be transformed.
//
// Step 2b
func (plot *Plot) PrepareScales(data *DataFrame, aes AesMapping) {
	println("PrepareScales data:")
	data.Print(os.Stdout)
	scaleable := map[string]bool{
		"x":        true,
		"y":        true,
		"color":    true,
		"fill":     true,
		"alpha":    true,
		"size":     true,
		"linetype": true,
		"shape":    true,
	}

	for a := range aes {
		if !scaleable[a] {
			fmt.Printf("PrepareScales() %q is un-scalable\n", a)
			continue
		}

		plotScale, plotOk := plot.Scales[a]
		panelOk := false
		if len(plot.Panels) > 0 {
			_, panelOk = plot.Panels[0][0].Scales[a]
		}
		switch {
		case plotOk && panelOk:
			// Scale exists and has been distributet to the panels
			// already.
			fmt.Printf("PrepareScales() %q already distributed\n", a)
		case plotOk && !panelOk:
			// Must be a user set scale on plot; just distribute.
			fmt.Printf("PrepareScales() %q distributed from plot\n", a)
			plot.distributeScale(plotScale, a)
		case !plotOk && !panelOk:
			// Auto-generated scale, first occurence of this scale.
			name, typ := aes[a], data.Columns[a].Type
			fmt.Printf("PrepareScales() %q create new and distribute\n", a)
			plotScale = NewScale(a, name, typ)
			plot.Scales[a] = plotScale
			plot.distributeScale(plotScale, a)
		case !plotOk && panelOk:
			panic("This should never happen.")
		}

		// Transform data if scale request such a transform.
		if plotScale.Transform != nil && plotScale.Transform != &IdentityScale {
			// TODO: This test should happen much earlier.
			if plotScale.Discrete || plotScale.Time {
				plot.Warnf("Cannot transform discrete or time scale %s %q",
					plotScale.Aesthetic, plotScale.Name)
				plotScale.Transform = &IdentityScale
			} else {
				field := data.Columns[a]
				field.Apply(plotScale.Transform.Trans)
				println("  Transformed data on scale ", a)
			}
		}

		// Pre-train scales on all panels
		for r := range plot.Panels {
			for c := range plot.Panels[r] {
				scale := plot.Panels[r][c].Scales[a]
				_, ok := data.Columns[a]
				println("Training", r, c, scale.Name, a, ok)
				scale.Train(data.Columns[a])
			}
		}
	}

}

// distributeScale will distribute scale to all panels. Most of the time
// all panels share one instance of a scale. But x- and y-scales may be free
// between rows and columns in which the panels recieve a copy.
func (plot *Plot) distributeScale(scale *Scale, aes string) {
	sharing := plot.scaleSharing(aes)
	switch sharing {
	case "all-panels":
		// All panels share the same scale.
		for r := range plot.Panels {
			for c := range plot.Panels[r] {
				plot.Panels[r][c].Scales[aes] = scale
			}
		}
	case "col-shared":
		// Each column share an individual copy of the scale.
		for r := range plot.Panels {
			cpy := *scale
			for c := range plot.Panels[r] {
				plot.Panels[r][c].Scales[aes] = &cpy
			}
		}
	case "row-shared":
		// Add appropriate scale to all panels.
		for c := range plot.Panels[0] {
			cpy := *scale
			for r := range plot.Panels {
				plot.Panels[r][c].Scales[aes] = &cpy
			}
		}
	default:
		panic("Ooops " + plot.scaleSharing(aes))
	}
}

// scaleSharing determines which panels share the sclae for the aesthetic aes:
// Only x and y can be not-shared in a feceted plot with set FreeScale.
func (plot *Plot) scaleSharing(aes string) string {
	if aes != "x" && aes != "y" {
		return "all-panels"
	}

	free := plot.Faceting.FreeScale

	if free == "" {
		return "all-panels"
	}

	if aes == "x" && strings.Index(free, "x") != -1 {
		// Scale for x axis, but x is 'free' i.e. each column may have
		// its own x-scale, but this one is shared along the whole
		// column.
		return "col-shared"
	}

	if aes == "y" && strings.Index(free, "y") != -1 {
		return "row-shared"
	}

	return "all-panels"
}

// -------------------------------------------------------------------------
// Step 3: Satistical Transformation

func (p *Panel) ComputeStatistics() {
	fmt.Printf("Panel %q: ComputeStatistics()\n", p.Name)

	for _, layer := range p.Layers {
		layer.ComputeStatistics()
	}
}

// ComputeStatistics computes the statistical transform. Might be the identity.
//
// Step 3 in design.
func (layer *Layer) ComputeStatistics() {
	if layer.Stat == nil {
		fmt.Printf("Layer %q: ComputeStatistics() nil stat\n", layer.Name)
		return // The identity statistical transformation.
	}
	fmt.Printf("Layer %q: ComputeStatistics() %q\n", layer.Name, layer.Stat.Name())

	// Make sure all needed aesthetics (columns) are present in
	// our data frame.
	// Step 3a.
	needed := layer.Stat.Info().NeededAes
	for _, aes := range needed {
		if _, ok := layer.Data.Columns[aes]; !ok {
			layer.Panel.Plot.Warnf("Stat %s in Layer %s needs column %s",
				layer.Stat.Name(), layer.Name, aes)
			// TODO: more cleanup?
			layer.Geom = nil // Don't draw anything.
			return
		}
	}

	// Handling of excess fields. TODO: Massive refactoring needed.
	usedByStat := NewStringSetFrom(needed)
	usedByStat.Join(NewStringSetFrom(layer.Stat.Info().OptionalAes))
	additionalFields := NewStringSetFrom(layer.Data.FieldNames())
	additionalFields.Remove(usedByStat)

	// TODO: all handling related code
	/***********************************************************
		handling := layer.Stat.Info().ExtraFieldHandling

		// Make sure all excess fields are discrete and abort on
		// any continuous field.
		for _, f := range fields.Elements() {
			if !layer.Data.Columns[f].Discrete() {
				layer.Plot.Warnf("Stat %s in Layer %s cannot cope with continous excess fields %s",
					layer.Stat.Name(), layer.Name, f)
				// TODO: more cleanup?
				layer.Geom = nil // Don't draw anything.
				return
			}
		}
	        *************************************************************/

	// Do the transform recursively. Step 3b
	fmt.Printf("Layer %q: ComputeStatistics() data before %d %v\n",
		layer.Name, layer.Data.N, layer.Data.FieldNames())
	layer.Data = applyRec(layer.Data, layer.Stat, layer.Panel, additionalFields.Elements())
	if layer.Data != nil {
		fmt.Printf("Layer %q: ComputeStatistics() data after %d %v\n",
			layer.Name, layer.Data.N, layer.Data.FieldNames())
	} else {
		fmt.Printf("Layer %q: ComputeStatistics() data after is nil\n",
			layer.Name)
	}
}

// Recursively partition data on the the additional fields, apply stat and
// combine the result.
func applyRec(data *DataFrame, stat Stat, p *Panel, additionalFields []string) *DataFrame {
	if len(additionalFields) == 0 {
		return stat.Apply(data, p)
	}

	field := additionalFields[0]
	var result *DataFrame
	levels := Levels(data, field).Elements()
	partition := Partition(data, field, levels)
	for i, part := range partition {
		// Recursion
		part = applyRec(part, stat, p, additionalFields[1:])

		// Re-add the field which was stripped during partitioning.
		af := data.Columns[field].Const(levels[i], part.N)
		part.Columns[field] = af

		// Combine results.
		if i == 0 {
			result = part
		} else {
			result.Append(part)
		}
	}
	return result
}

// -------------------------------------------------------------------------
// Step 4: Wiring Result of Stat to Input of Geom

func (p *Panel) WireStatToGeom() {
	fmt.Printf("Panel %q: WireStatToGeoms()\n", p.Name)

	// A stat may return a nil data frame, e.g. if the input to the stat
	// itself was empty. In this case no wireing is needed and the layer
	// geom can be removed.

	for _, layer := range p.Layers {
		if layer.Data == nil {
			// Data was cleared by stat.
			layer.Geom = nil
			continue
		}
		layer.WireStatToGeom()
	}
}

func (layer *Layer) WireStatToGeom() {
	// Now we have a new data frame with possible new columns.
	// These may be mapped to plot aestetics by plot.StatMapping.
	// Do this now.
	if len(layer.StatMapping) != 0 {
		fmt.Printf("Layer %s: preparing scales with stat mapping %v\n",
			layer.Name, layer.StatMapping)

		// Rename mapped fields to their aestethic name
		for a, f := range layer.StatMapping {
			println("Renaming ", f, " to ", a, " because of stat mapping.")
			layer.Data.Rename(f, a)
		}
		layer.Panel.Plot.PrepareScales(layer.Data, layer.StatMapping)
	}

	// TODO: Geoms should contain aesthetict only as input, so there
	// should not be a need for both, StatMapping and GeomMapping, or?

	// Rename fields produces by statistical transform to names
	// the geom understands.
	// TODO: When to set e.g. color to a certain value?
	for aes, field := range layer.GeomMapping {
		layer.Data.Rename(field, aes)
	}

}

// -------------------------------------------------------------------------
// Step 5: Constructing Geoms

// ConstructGeoms sets up the geoms so that they can be rendered. This includes
// an optional renaming of stat-generated fields to geom-understandable fields,
// applying positional adjustment to same-x geoms and reparametrization to
// fundamental geoms.
//
func (p *Panel) ConstructGeoms() {
	fmt.Printf("Panel %q: ConstructGeoms()\n", p.Name)

	for _, layer := range p.Layers {
		layer.ConstructGeoms()
	}
}

func (layer *Layer) ConstructGeoms() {
	if layer.Geom == nil {
		if layer.Data != nil {
			layer.Panel.Plot.Warnf("No Geom specified in layer %s.", layer.Name)
		}
		return
	}

	// Make sure all needed slots are present in the data frame
	slots := NewStringSetFrom(layer.Geom.NeededSlots())
	dfSlots := NewStringSetFrom(layer.Data.FieldNames())
	slots.Remove(dfSlots)
	if len(slots) > 0 {
		layer.Panel.Plot.Warnf("Missing slots in geom %s in layer %s: %v",
			layer.Geom.Name(), layer.Name, slots.Elements())
		layer.Geom = nil
		return
	}

	println("  ", layer.Name, layer.Data.N)
	layer.Fundamentals = layer.Geom.Construct(layer.Data, layer.Panel)
}

// -------------------------------------------------------------------------
// Step 6: Prepare Scales
func (p *Panel) FinalizeScales() {
	fmt.Printf("Panel %q: FinalizeScalse()\n", p.Name)
	for _, scale := range p.Scales {
		scale.Finalize()
	}
}

// -------------------------------------------------------------------------
// Step 7: Render fundamental Geoms

func (p *Panel) RenderGeoms() {
	fmt.Printf("Panel %q: RenderGeoms()\n", p.Name)
	for _, layer := range p.Layers {
		if len(layer.Fundamentals) == 0 {
			continue
		}
		for _, fund := range layer.Fundamentals {
			data := fund.Data
			aes := fund.Geom.Aes(p.Plot)
			layer.Grobs = append(layer.Grobs, fund.Geom.Render(p, data, aes)...)
		}
	}
}

// -------------------------------------------------------------------------
// Plot drawing

// Draw generates all parts of the plot and renders the output.
func (plot *Plot) Draw(width, height vg.Length, out io.Writer) {
	plot.CreatePanels()

	plot.Check()

	for r := range plot.Panels {
		for c := range plot.Panels[r] {
			panel := plot.Panels[r][c]

			// Prepare data: map aestetics, add scales, clean data frame and
			// apply scale transformations. Mapped scales are pre-trained.
			// Step 2
			panel.PrepareData()
			println("RRRRRRRR")
			panel.Data.Print(os.Stdout)

			// The second step: Compute statistics.
			// If a layer has a statistical transform: Apply this transformation
			// to the data frame of this layer.
			// Step 3
			panel.ComputeStatistics()

			// Make sure the output of the stat matches the input expected
			// by the geom.
			// Step 4
			panel.WireStatToGeom()

			// Construct geoms
			// Apply geom specific position adjustments, train the involved
			// scales and produce a set of fundamental geoms.
			// Step 5
			panel.ConstructGeoms()
		}
	}

	for r := range plot.Panels {
		for _, panel := range plot.Panels[r] {

			// Finalize scales: Setup remaining fields.
			// This can be done only after each panel completed
			// the steps 2-5 ConstructGeoms which might change
			// the scales.
			// Step 6
			panel.FinalizeScales()

			// Render the fundamental Geoms to Grobs using scales.
			// Step 7
			panel.RenderGeoms()
		}
	}

	// TODO: Maybe nicer: render everything to grobs, compute
	// bounding box for GrobText, use this to layout stuff
	// draw everything.

	pngCanvas := vgimg.PngCanvas{Canvas: vgimg.New(width, height)}
	vg.Initialize(pngCanvas)

	globalVP := Viewport{
		X0:     0,
		Y0:     0,
		Width:  width,
		Height: height,
		Canvas: pngCanvas,
	}
	plot.Layout(globalVP)

	// Render rest of elements (guides, titels, factting, ...)
	// Step 8
	plot.RenderVisuals()

	// Output everythign to w
	pngCanvas.WriteTo(out)
}

// -------------------------------------------------------------------------
// Panel creation and layout.

// CreatePanels populates p.Panels, governed by p.Faceting.
//
// Not only p.Data is facetted but p.Layers also (if they contain own data).
func (plot *Plot) CreatePanels() {
	if plot.Faceting.Columns == "" && plot.Faceting.Rows == "" {
		plot.createSinglePanel()
	} else {
		plot.createGridPanels()
	}
	println("Directly after panel creation")
	plot.Check()
}

func (plot *Plot) createSinglePanel() {
	println("createSinglePanel()")
	panel := &Panel{
		Plot:   plot,
		Data:   plot.Data,
		Aes:    plot.Aes.Copy(),
		Layers: make([]*Layer, len(plot.Layers)),
		Scales: make(map[string]*Scale),
	}

	plot.Panels = [][]*Panel{[]*Panel{panel}}
	for i, layer := range plot.Layers {
		plot.Panels[0][0].Layers[i] = layer
		plot.Panels[0][0].Layers[i].Panel = panel
	}
}

func (p *Plot) createGridPanels() {
	println("createGridPanel()")
	// Process faceting: How many facets are there, how are they named
	rows, cols := 1, 1
	var cunq []float64
	var runq []float64
	var cunqs []string
	var runqs []string

	// Make sure facetting can be done and determine number of
	// rows and columns.
	if p.Faceting.Columns != "" {
		f := p.Data.Columns[p.Faceting.Columns]
		if !f.Discrete() {
			panic(fmt.Sprintf("Cannot facet over %s (type %s)",
				p.Faceting.Columns, f.Type.String()))
		}
		cunq = Levels(p.Data, p.Faceting.Columns).Elements()
		cols = len(cunq)
		cunqs = make([]string, cols)

		for c := 0; c < cols; c++ {
			cunqs[c] = f.String(cunq[c])
		}
	}
	if p.Faceting.Rows != "" {
		f := p.Data.Columns[p.Faceting.Rows]
		if !f.Discrete() {
			panic(fmt.Sprintf("Cannot facet over %s (type %s)",
				p.Faceting.Columns, f.Type.String()))
		}
		runq = Levels(p.Data, p.Faceting.Rows).Elements()
		rows = len(runq)
		runqs = make([]string, rows)
		for r := 0; r < rows; r++ {
			runqs[r] = f.String(runq[r])
		}
	}

	p.Panels = make([][]*Panel, rows, rows+1)
	for r := 0; r < rows; r++ {
		p.Panels[r] = make([]*Panel, cols, cols+1)
		rowData := Filter(p.Data, p.Faceting.Rows, runq[r])
		for c := 0; c < cols; c++ {
			panel := &Panel{
				Name:   fmt.Sprintf("%d/%d %s/%s", r, c, runqs[r], cunqs[c]),
				Plot:   p,
				Scales: make(map[string]*Scale),
				Data:   Filter(rowData, p.Faceting.Columns, cunq[c]),
			}
			fmt.Printf("panel %d,%d = %p\n", r, c, panel)
			for _, orig := range p.Layers {
				// Copy plot layers to panel, make sure layer data is filtered.
				layer := &Layer{
					Panel:       panel,
					Name:        orig.Name,
					Stat:        orig.Stat,
					Geom:        orig.Geom,
					DataMapping: orig.DataMapping,
					StatMapping: orig.StatMapping,
					GeomMapping: orig.GeomMapping,
				}
				if orig.Data != nil {
					layer.Data = Filter(orig.Data, p.Faceting.Rows, runq[r])
					layer.Data = Filter(layer.Data, p.Faceting.Columns, cunq[c])
				}
				panel.Layers = append(panel.Layers, layer)
			}
			p.Panels[r][c] = panel
			fmt.Printf("Panel 0,0 %q Layer 0 panel=%p\n",
				p.Panels[0][0].Name, p.Panels[0][0].Layers[0].Panel)

			if p.Faceting.Totals {
				// Add a total columns containing all data of this row.
				panel := &Panel{
					Name:   fmt.Sprintf("%d/%d %s/-all-", r, c+1, runqs[r]),
					Plot:   p,
					Data:   rowData,
					Scales: make(map[string]*Scale),
				}
				for _, layer := range p.Layers {
					if layer.Data != nil {
						layer.Data = Filter(layer.Data, p.Faceting.Rows, runq[r])
					}
					layer.Panel = panel
					panel.Layers = append(panel.Layers, layer)
				}
				p.Panels[r] = append(p.Panels[r], panel)
			}
		}
	}
	if p.Faceting.Totals {
		// Add a total row containing all column data.
		p.Panels = append(p.Panels, make([]*Panel, cols+1))
		for c := 0; c < cols; c++ {
			colData := Filter(p.Data, p.Faceting.Columns, cunq[c])
			panel := &Panel{
				Name:   fmt.Sprintf("%d/%d -all-/%s", rows, c, cunqs[c]),
				Plot:   p,
				Data:   colData,
				Scales: make(map[string]*Scale),
			}
			for _, layer := range p.Layers {
				if layer.Data != nil {
					layer.Data = Filter(layer.Data, p.Faceting.Columns, cunq[c])
				}
				layer.Panel = panel
				panel.Layers = append(panel.Layers, layer)
			}
			p.Panels[rows][c] = panel
		}
		panel := &Panel{
			Name:   fmt.Sprintf("%d/%d -all-/-all-", rows, cols),
			Plot:   p,
			Data:   p.Data,
			Scales: make(map[string]*Scale),
		}
		for _, layer := range p.Layers {
			layer.Panel = panel
			panel.Layers = append(panel.Layers, layer)
		}
		p.Panels[rows][cols] = panel
		cols++
		rows++
	}

	fmt.Printf("\nPanel 0,0 %q Layer 0 panel=%p\n",
		p.Panels[0][0].Name, p.Panels[0][0].Layers[0].Panel)
	// p.Panels[0][0].Data.Print(os.Stdout)

}

// -------------------------------------------------------------------------
// Layouting

// Layout computes suitable viewports for the different components.
func (plot *Plot) Layout(v Viewport) {
	plot.Viewport = make(map[string]Viewport)

	// Lets use a fixed layout.
	plot.Viewport["Title"] = SubViewport(v, 0, 0.95, 1, 0.05)
	plot.Viewport["Col-Labels"] = SubViewport(v, 0, 0.9, 1, 0.05)
	plot.Viewport["Row-Labels"] = SubViewport(v, 0.85, 0.1, 0.05, 0.08)
	plot.Viewport["X-Label"] = SubViewport(v, 0.1, 0, 0.75, 0.05)
	plot.Viewport["Y-Label"] = SubViewport(v, 0, 0.1, 0.1, 0.8)

	nrows := len(plot.Panels)
	ncols := len(plot.Panels[0])
	sepx := 0.02
	sepy := 0.02
	pwidth := (0.75 - sepx*float64(ncols-1)) / float64(ncols)
	pheight := (0.8 - sepy*float64(nrows-1)) / float64(nrows)

	for r := 0; r < nrows; r++ {
		for c := 0; c < ncols; c++ {
			panelId := fmt.Sprintf("Panel-%d-%d", r, c)
			x := 0.1 + float64(c)*(pwidth+sepx)
			y := 0.1 + float64(r)*(pheight+sepy)
			plot.Viewport[panelId] = SubViewport(v, x, y, pwidth, pheight)
		}
	}
}

// -------------------------------------------------------------------------
// Step 8: Render remaining parts of plot

func (plot *Plot) RenderVisuals() {
	// Title
	if plot.Title != "" {
		t := GrobText{x: 0.5, y: 0.5, vjust: 0.5, hjust: 0.5, text: plot.Title}
		t.Draw(plot.Viewport["Title"])
	}

	if name := plot.Scales["x"].Name; name != "" {
		t := GrobText{x: 0.5, y: 0.1, vjust: 0, hjust: 0.5, text: name}
		t.Draw(plot.Viewport["X-Label"])
	}

	if name := plot.Scales["y"].Name; name != "" {
		t := GrobText{x: 0.1, y: 0.5, vjust: 0.5, hjust: 0.5, text: name, angle: math.Pi / 2}
		t.Draw(plot.Viewport["Y-Label"])
	}

	showX, showY := false, false
	for r := range plot.Panels {
		showX = r+1 == len(plot.Panels)
		for c, panel := range plot.Panels[r] {
			showY = c == 0
			panelId := fmt.Sprintf("Panel-%d-%d", r, c)
			panel.Draw(plot.Viewport[panelId], showX, showY)
		}
	}
}

func (panel *Panel) Draw(vp Viewport, showX, showY bool) {
	// Draw the background first.
	panelBG := MergeStyles(panel.Plot.Theme.PanelBG, DefaultTheme.PanelBG)
	// TODO: how to _not_ draw something?
	GrobRect{
		xmin: 0, ymin: 0,
		xmax: 1, ymax: 1,
		fill: String2Color(panelBG["fill"])}.Draw(vp)
	points := []struct{ x, y float64 }{{0, 0}, {1, 0}, {1, 1}, {0, 1}, {0, 0}}
	GrobPath{points: points,
		linetype: String2LineType(panelBG["linetype"]),
		size:     String2Float(panelBG["size"], 0, 20),
		color:    String2Color(panelBG["color"])}.Draw(vp)

	// Draw grid lines.
	sx := panel.Scales["x"]
	sy := panel.Scales["y"]
	major := MergeStyles(panel.Plot.Theme.GridMajor, DefaultTheme.GridMajor)
	// TODO minor := MergeStyles(panel.Plot.Theme.GridMinor, DefaultTheme.GridMinor)
	for i, x := range sx.Breaks {
		xv := sx.Pos(x)
		GrobLine{x0: xv, y0: 0, x1: xv, y1: 1,
			linetype: String2LineType(major["linetype"]),
			size:     String2Float(major["size"], 0, 20),
			color:    String2Color(major["color"])}.Draw(vp)
		if !showX {
			continue
		}
		GrobLine{x0: xv, y0: 0, x1: xv, y1: -0.02,
			linetype: SolidLine,
			size:     1,
			color:    BuiltinColors["gray"]}.Draw(vp)
		GrobText{x: xv, y: -0.02, hjust: 0.5, vjust: 1, text: sx.Labels[i],
			size:  12,
			color: BuiltinColors["gray20"]}.Draw(vp)
	}
	for i, y := range sy.Breaks {
		yv := sy.Pos(y)
		GrobLine{x0: 0, y0: yv, x1: 1, y1: yv,
			linetype: String2LineType(major["linetype"]),
			size:     String2Float(major["size"], 0, 20),
			color:    String2Color(major["color"])}.Draw(vp)
		GrobLine{x0: 0, y0: yv, x1: -0.02, y1: yv,
			linetype: SolidLine,
			size:     1,
			color:    BuiltinColors["gray"]}.Draw(vp)
		GrobText{x: -0.02, y: yv, hjust: 1, vjust: 0.5, text: sy.Labels[i],
			size:  12,
			color: BuiltinColors["gray20"]}.Draw(vp)
	}

	// Draw the layers.
	for _, layer := range panel.Layers {
		for _, g := range layer.Grobs {
			g.Draw(vp)
		}
	}
}

// -------------------------------------------------------------------------
// Misc

func UniqueStrings(s []string) (u []string) {
	if len(s) <= 1 {
		return s
	}
	sort.Strings(s)
	t := s[0]
	for i := 1; i <= len(s); i++ {
		if s[i] == t {
			continue
		}
		t = s[i]
		u = append(u, t)
	}
	return u
}

// AesMapping controlls the mapping of fields of a data frame to aesthetics.
// The zero value of AesMapping is the identity mapping.
//
// The following formats are used:
//     "<fieldname>"        map aesthetic to this field
//     "fixed: <value>"     set aesthetics to the given value
type AesMapping map[string]string

func (m AesMapping) Used(includeAll bool) (aes, names []string) {
	for a, n := range m {
		aes = append(aes, a)
		if includeAll || strings.Index(n, ":") == -1 {
			names = append(names, n)
		}
	}
	sort.Strings(aes)
	sort.Strings(names)
	return aes, names
}

func (m AesMapping) Copy() AesMapping {
	c := make(AesMapping, len(m))
	for a, n := range m {
		c[a] = n
	}
	return c
}

// Merge merges set values in all the ams into m and returns the merged mapping.
func MergeAes(ams ...AesMapping) AesMapping {
	merged := MergeStyles(ams...)
	for k, v := range merged {
		if v == "" {
			delete(merged, k)
		}
	}
	return merged
}

// Combine merges set values in all the ams into m and returns the merged mapping.
// Later values in ams overwrite earlier ones or values in m.
func (m AesMapping) Combine(ams ...AesMapping) AesMapping {
	merged := m.Copy()
	for _, am := range ams {
		for aes, fname := range am {
			merged[aes] = fname
		}
	}
	return merged
}

func (plot *Plot) Check() {
	fmt.Printf("=============== Check of plot ================\n")
	for r := range plot.Panels {
		for c := range plot.Panels[r] {
			panel := plot.Panels[r][c]
			if panel.Plot != plot {
				fmt.Printf("Panel %d,%d %q: panel.Plot=%p but plot=%p\n",
					r, c, panel.Name, panel, plot)
			}
			for i := range panel.Layers {
				layer := panel.Layers[i]
				if layer.Panel != panel {
					fmt.Printf("Panel %d,%d %q, Layer %d %q: layer.Panel=%p but panel=%p\n",
						r, c, panel.Name, i, layer.Name, layer.Panel, panel)

				}
			}
		}
	}
	fmt.Printf("---------------- check done ------------------\n")
}
